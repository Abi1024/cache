/*
	merge_sort_strings.cpp:
		This program uses external memory merge sort (from the STXXL library) to sort an input database.
		The input database has to be of the format generated by our modified gensort() -- see /gen_sort/gensort.c.
	Command to execute: ./merge_sort_strings MemoryAvailable GenSortDBFile SortedDBDestinationFile

	Sample gensort databases (from size 1kB to 100gB) are available in: /database_sample/
*/

#define USE_STXXL
#include <stxxl.h>
#include <algorithm>
#include <vector>
#include <fstream>
#include <ctime>
#include <stdlib.h>
/*This is the structure of the records generated by the gensort.c program*/
struct record
{
	char key[11] = "", data1[33] = "", data2[53] = "";
};

/*Modified ">>" operator for reading the database*/
std::istream& operator >> (std::istream& i, record& entry)
{
	i>>entry.key;
	i>>entry.data1;
	i>>entry.data2;
	return i;
}

/*Modified "<<" operator for writing the sorted database back to disk*/
std::ostream& operator << (std::ostream& o, record& entry)
{
	o<<"KEY: "<<entry.key<<", DATA: "<<entry.data1<<entry.data2<<std::endl;
	return o;
}

/*A comparator for our record structure*/
struct SortByKey
{
	bool operator () (const record& a, const record& b) const
	{
		return strcmp(a.key, b.key) < 0 || (strcmp(a.key, b.key) == 0 && strcmp(a.data1, b.data1) < 0);
	}
	static record min_value()
	{
		record min;
		/*The smallest ASCII char generated by gensort() is '!': see "/gen_sort/gensort.c"*/
		std::string key = "!!!!!!!!!!";
		std::string data1 = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
		std::string data2 = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
		strcpy(min.key, key.c_str());
		strcpy(min.data1, data1.c_str());
		strcpy(min.data2, data2.c_str());
		return min;
	}
	static record max_value()
	{
		record max;
		/*The largest ASCII char generated by gensort() is '~': see "/gen_sort/gensort.c"*/
		std::string key = "~~~~~~~~~~";
		std::string data1 = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
		std::string data2 = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
		strcpy(max.key, key.c_str());
		strcpy(max.data1, data1.c_str());
		strcpy(max.data2, data2.c_str());
		return max;
	}
};

void print_usage(const char* program)
{
	std::cout<<"USAGE: "<<program<<" memory-to-be-used file-to-be-sorted destination-file"<<std::endl;
	std::cout<<"By default storing the sorted database is disabled, to enable it you need to uncomment the write back in my code"<<std::endl;
	std::cout<<"So just provide a dummy filename"<<std::endl;
}

const unsigned int block_size = sizeof(record) * 16384;
typedef stxxl::vector<record, 26, stxxl::lru_pager<128>, block_size> rec_vector;

int main(int argc, char* argv[])
{

	if(argc < 4)
	{
		print_usage(argv[0]);
		return 1;
	}
	printf("Testing code\n");
	printf("Size of a record:  %zu\n", sizeof(record));
	STXXL_MSG("[LOG] MERGESORT: "<<argv[1]<<" MB, DB USED: "<<argv[2]);

	const unsigned long long M = atoll(argv[1])*1024*1024;
	stxxl::timer start_p1;
	start_p1.start();
	std::fstream in(argv[2], std::ios::in);
	rec_vector records;
	int record_counter = 0;
	while(!in.eof())
	{
		record_counter++;
		record temp;
		in>>temp.key>>temp.data1>>temp.data2;
		records.push_back(temp);
	}
	printf("Tsting if I made it this far!\n");
	start_p1.stop();
	STXXL_MSG("[LOG] Total initializing time: "<<(start_p1.mseconds()/1000));

	stxxl::timer start_p2;
	stxxl::block_manager * bm = stxxl::block_manager::get_instance();
	stxxl::stats* Stats = stxxl::stats::get_instance();
	stxxl::stats_data stats_begin(*Stats);
	start_p2.start();
	stxxl::sort(records.begin(), records.end(), SortByKey(), M);
	start_p2.stop();
	STXXL_MSG("[LOG] IO Statistics for sorting: "<<(stxxl::stats_data(*Stats) - stats_begin));
	STXXL_MSG("[LOG] Max MB allocated:  " << bm->get_maximum_allocation()/(1024*1024));
	STXXL_MSG("[LOG] Total sorting time: "<<(start_p2.mseconds()/1000));

	std::fstream out(argv[3], std::ios::out);
	/*for(unsigned int i = 0 ; i < records.size() ; i ++)
		out<<"RECORD: "<<i<<", "<<records[i]<<std::endl;
	*/
	STXXL_MSG("[LOG] Total process time: "<<(start_p1.mseconds()/1000+start_p2.mseconds()/1000));
	return 10;
}
